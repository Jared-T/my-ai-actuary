"""
Artefact models for tracking generated files and outputs.

Artefacts are the outputs of workflow runs - reports, data files,
visualizations, and other work products that require storage and approval.
"""

from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING
from uuid import UUID

from sqlalchemy import BigInteger, DateTime, Enum as SQLEnum, ForeignKey, String, Text, func
from sqlalchemy.dialects.postgresql import JSONB, UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from core.database import Base
from models.base import AuditMixin, SoftDeleteMixin, TraceableMixin, UUIDMixin

if TYPE_CHECKING:
    from models.approval import Approval
    from models.engagement import Engagement
    from models.workflow import WorkflowRun


class ArtefactType(str, Enum):
    """Types of artefacts generated by workflows."""

    # Data files
    DATA_FILE = "data_file"
    CSV = "csv"
    EXCEL = "excel"
    PARQUET = "parquet"

    # Documents
    REPORT = "report"
    PDF = "pdf"
    WORD = "word"
    MARKDOWN = "markdown"

    # Visualizations
    CHART = "chart"
    DASHBOARD = "dashboard"
    GRAPH = "graph"

    # Analysis outputs
    MODEL_OUTPUT = "model_output"
    TRIANGLE = "triangle"
    PROJECTION = "projection"
    SENSITIVITY = "sensitivity"

    # Code and notebooks
    NOTEBOOK = "notebook"
    SCRIPT = "script"

    # Logs and metadata
    LOG = "log"
    METADATA = "metadata"
    CONFIG = "config"

    # Other
    ARCHIVE = "archive"
    OTHER = "other"


class ArtefactStatus(str, Enum):
    """Status of an artefact in its lifecycle."""

    DRAFT = "draft"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    SUPERSEDED = "superseded"
    ARCHIVED = "archived"


class Artefact(Base, UUIDMixin, AuditMixin, SoftDeleteMixin, TraceableMixin):
    """
    Generated artefact from a workflow run.

    Artefacts are immutable work products that require tracking for
    audit, versioning, and approval purposes. Content is stored externally
    (Supabase Storage) with hash verification for integrity.
    """

    __tablename__ = "artefacts"

    # Parent associations
    engagement_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("engagements.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    workflow_run_id: Mapped[UUID | None] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("workflow_runs.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    # Artefact identification
    artefact_type: Mapped[ArtefactType] = mapped_column(
        SQLEnum(ArtefactType, name="artefact_type", create_constraint=True),
        nullable=False,
        index=True,
    )

    name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Display name for the artefact",
    )

    description: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
    )

    # File information
    file_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Original filename",
    )

    mime_type: Mapped[str] = mapped_column(
        String(100),
        nullable=False,
        comment="MIME type of the file",
    )

    file_size: Mapped[int] = mapped_column(
        BigInteger,
        nullable=False,
        comment="File size in bytes",
    )

    # Storage location
    storage_path: Mapped[str] = mapped_column(
        String(1000),
        nullable=False,
        comment="Path in Supabase Storage",
    )

    storage_bucket: Mapped[str] = mapped_column(
        String(100),
        default="artefacts",
        nullable=False,
        comment="Supabase Storage bucket name",
    )

    # Integrity verification
    content_hash: Mapped[str] = mapped_column(
        String(64),
        nullable=False,
        index=True,
        comment="SHA-256 hash of file content for integrity verification",
    )

    # Status and versioning
    status: Mapped[ArtefactStatus] = mapped_column(
        SQLEnum(ArtefactStatus, name="artefact_status", create_constraint=True),
        default=ArtefactStatus.DRAFT,
        nullable=False,
        index=True,
    )

    version: Mapped[int] = mapped_column(
        BigInteger,
        default=1,
        nullable=False,
        comment="Version number for the artefact",
    )

    # Previous version reference (for versioning chain)
    previous_version_id: Mapped[UUID | None] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("artefacts.id", ondelete="SET NULL"),
        nullable=True,
        comment="Reference to the previous version of this artefact",
    )

    # Additional metadata
    # Named extra_metadata to avoid conflict with SQLAlchemy's reserved 'metadata' attribute
    extra_metadata: Mapped[dict | None] = mapped_column(
        JSONB,
        nullable=True,
        default=None,
        name="metadata",  # Keep DB column name as 'metadata' for backward compatibility
        comment="Additional metadata: tags, properties, etc.",
    )

    # Relationships
    # Note: Use lazy="raise" to prevent accidental N+1 queries.
    # Explicitly load relationships when needed using selectinload() or joinedload()
    engagement: Mapped["Engagement"] = relationship(
        "Engagement",
        back_populates="artefacts",
        lazy="raise",  # Require explicit loading
    )

    workflow_run: Mapped["WorkflowRun | None"] = relationship(
        "WorkflowRun",
        back_populates="artefacts",
        lazy="raise",  # Require explicit loading
    )

    approvals: Mapped[list["Approval"]] = relationship(
        "Approval",
        back_populates="artefact",
        cascade="all, delete-orphan",
        lazy="raise",  # Require explicit loading
    )

    # Self-referential relationship for version chain
    # Use this to traverse the version history of an artefact
    previous_version: Mapped["Artefact | None"] = relationship(
        "Artefact",
        remote_side="Artefact.id",
        lazy="raise",  # Require explicit loading
    )

    def __repr__(self) -> str:
        return (
            f"<Artefact(id={self.id}, type={self.artefact_type.value}, "
            f"name={self.name!r}, status={self.status.value})>"
        )

    @property
    def storage_url(self) -> str:
        """Construct the full storage URL."""
        return f"{self.storage_bucket}/{self.storage_path}"

    @property
    def is_approved(self) -> bool:
        """Check if artefact has been approved."""
        return self.status == ArtefactStatus.APPROVED

    @property
    def requires_approval(self) -> bool:
        """Check if artefact is waiting for approval."""
        return self.status == ArtefactStatus.PENDING_REVIEW

    def submit_for_review(self) -> None:
        """Submit artefact for review/approval."""
        if self.status != ArtefactStatus.DRAFT:
            raise ValueError(f"Cannot submit artefact in {self.status.value} status")
        self.status = ArtefactStatus.PENDING_REVIEW

    def approve(self) -> None:
        """Mark artefact as approved."""
        if self.status != ArtefactStatus.PENDING_REVIEW:
            raise ValueError(f"Cannot approve artefact in {self.status.value} status")
        self.status = ArtefactStatus.APPROVED

    def reject(self) -> None:
        """Mark artefact as rejected."""
        if self.status != ArtefactStatus.PENDING_REVIEW:
            raise ValueError(f"Cannot reject artefact in {self.status.value} status")
        self.status = ArtefactStatus.REJECTED

    def supersede(self) -> None:
        """Mark artefact as superseded by a newer version."""
        self.status = ArtefactStatus.SUPERSEDED

    def archive(self) -> None:
        """Archive the artefact."""
        self.status = ArtefactStatus.ARCHIVED
